// Generated by CoffeeScript 1.7.1
(function() {
  var Character, Codey, CodeyParts, Cube, Cylinder, Dimension, Game, Movement, Position, PositionCenter, Renderer, Wheel, Window,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Game = (function() {
    Game.prototype.level = 1;

    function Game() {
      var ambientLight, aspectRatio, cube, dim, directionalLight, geometry, ground, i, light, line, material, projector, size, step, _i, _j;
      this.timer = Date.now();
      projector = new THREE.Projector;
      Physijs.scripts.worker = '../vendor/physijs_worker.js';
      Physijs.scripts.ammo = '../vendor/ammo.js';
      this.renderer = new Renderer().t();
      this.scene = new Physijs.Scene();
      this.scene.setGravity(new THREE.Vector3(0, -100, 0));
      this.scene.addEventListener('update', (function(_this) {
        return function() {
          return _this.scene.simulate(void 0, 2);
        };
      })(this));
      size = 500;
      step = 50;
      geometry = new THREE.Geometry();
      for (i = _i = -size; step > 0 ? _i <= size : _i >= size; i = _i += step) {
        geometry.vertices.push(new THREE.Vector3(-size, 0, i));
        geometry.vertices.push(new THREE.Vector3(size, 0, i));
        geometry.vertices.push(new THREE.Vector3(i, 0, -size));
        geometry.vertices.push(new THREE.Vector3(i, 0, size));
      }
      material = new THREE.LineBasicMaterial({
        color: 0x000000,
        opacity: 0.2
      });
      line = new THREE.Line(geometry, material);
      line.type = THREE.LinePieces;
      aspectRatio = Window.aspectRatio();
      size = 900;
      this.camera = new THREE.OrthographicCamera(-aspectRatio * size / 2, aspectRatio * size / 2, size / 2, -size / 2, -1000, 1000);
      this.controls = new THREE.PointerLockControls(this.camera);
      this.scene.add(this.controls.getObject());
      this.camera.position.y = 80;
      $('#camera-position-y').keyup((function(_this) {
        return function() {
          _this.camera.position.y = parseInt($('#camera-position-y').val());
          _this.camera.position.x = Math.cos(45) * 200;
          _this.camera.position.z = Math.sin(45) * 100;
          return _this.camera.lookAt(_this.scene.position);
        };
      })(this));
      $('#camera-position-x').keyup((function(_this) {
        return function() {
          _this.camera.position.x = parseInt($('#camera-position-x').val());
          return _this.camera.lookAt(_this.scene.position);
        };
      })(this));
      dim = new Dimension(100, 100, 100);
      light = new THREE.DirectionalLight(0xFFFFFF);
      light.target.position.copy(this.scene.position);
      light.castShadow = true;
      light.shadowCameraLeft = -60;
      light.shadowCameraTop = -60;
      light.shadowCameraRight = 60;
      light.shadowCameraBottom = 60;
      light.shadowCameraNear = 20;
      light.shadowCameraFar = 200;
      light.shadowBias = -.0001;
      light.shadowMapWidth = light.shadowMapHeight = 2048;
      light.shadowDarkness = .7;
      this.scene.add(light);
      ground = new Physijs.BoxMesh(new THREE.CubeGeometry(1000, 1, 1000), new THREE.MeshBasicMaterial({
        wireframe: true,
        color: 'red'
      }), 0);
      ground.receiveShadow = true;
      this.scene.add(ground);
      geometry = new THREE.BoxGeometry(step, step, step);
      material = new THREE.MeshLambertMaterial({
        color: 0xffffff,
        shading: THREE.FlatShading,
        overdraw: 0.5
      });
      for (i = _j = 0; _j <= 100; i = ++_j) {
        cube = new THREE.Mesh(geometry, material);
        cube.scale.y = Math.floor(Math.random() * 2 + 1);
        cube.position.x = Math.floor((Math.random() * 1000 - 500) / 50) * 50 + 25;
        cube.position.y = (cube.scale.y * 50) / 2;
        cube.position.z = Math.floor((Math.random() * 1000 - 500) / 50) * 50 + 25;
      }
      ambientLight = new THREE.AmbientLight(Math.random() * 0x10);
      this.scene.add(ambientLight);
      directionalLight = new THREE.DirectionalLight(Math.random() * 0xffffff);
      directionalLight.position.x = Math.random() - 0.5;
      directionalLight.position.y = Math.random() - 0.5;
      directionalLight.position.z = Math.random() - 0.5;
      directionalLight.position.normalize();
      this.scene.add(directionalLight);
      directionalLight = new THREE.DirectionalLight(Math.random() * 0xffffff);
      directionalLight.position.x = Math.random() - 0.5;
      directionalLight.position.y = Math.random() - 0.5;
      directionalLight.position.z = Math.random() - 0.5;
      directionalLight.position.normalize();
      this.scene.add(directionalLight);
      Codey.build_robot(this.scene);
      this.camera.position.x = Math.cos(45) * 200;
      this.camera.position.z = Math.sin(45) * 100;
      this.camera.lookAt(this.scene.position);
      this.scene.simulate();
      this.render();
    }

    Game.prototype.render = function() {
      return this.renderer.render(this.scene, this.camera);
    };

    Game.prototype.animate = function() {
      this.controls.update(Date.now() - this.timer);
      this.timer = Date.now();
      return this.render();
    };

    return Game;

  })();

  window.onload = function() {
    var animate, game;
    game = new Game();
    animate = function() {
      requestAnimationFrame(animate);
      return game.animate();
    };
    return animate();
  };

  CodeyParts = {};

  Character = (function() {
    function Character() {}

    return Character;

  })();

  Wheel = (function() {
    function Wheel() {
      var wheel_geometry, wheel_material;
      wheel_material = Physijs.createMaterial(new THREE.MeshLambertMaterial({
        color: 0x444444
      }), .8, .5);
      wheel_geometry = new THREE.CylinderGeometry(25, 25, 25, 8);
      this.wheel = new Physijs.CylinderMesh(wheel_geometry, wheel_material, 500);
      this.wheel.rotation.x = Math.PI / 2;
      this.wheel.position.y = 25;
      this.wheel.receiveShadow = this.wheel.castShadow = true;
    }

    Wheel.prototype.mesh = function() {
      return this.wheel;
    };

    Wheel.prototype.z = function(value) {
      this.wheel.position.z = value;
      return this;
    };

    Wheel.prototype.x = function(value) {
      this.wheel.position.x = value;
      return this;
    };

    return Wheel;

  })();

  Cylinder = (function() {
    function Cylinder() {
      var material;
      material = Physijs.createMaterial(new THREE.MeshNormalMaterial(), .8, .2);
      this.cylinder = new Physijs.BoxMesh(new THREE.CubeGeometry(200, 10, 120, 16, 1, false), material, 1000);
      this.cylinder.receiveShadow = this.cylinder.castShadow = true;
      this.cylinder.position.x = 0;
      this.cylinder.position.z = 0;
    }

    Cylinder.prototype.mesh = function() {
      return this.cylinder;
    };

    Cylinder.prototype.y = function(value) {
      return this.cylinder.position.y = value;
    };

    return Cylinder;

  })();

  CodeyParts.UnidirectionalWheels = (function() {
    var wheel_distance;

    wheel_distance = 80;

    function UnidirectionalWheels() {
      this.cylinder = new Cylinder();
      this.cylinder.y(55);
      this.left_wheel = new Wheel();
      this.left_wheel.x(wheel_distance).z(-wheel_distance);
      this.right_wheel = new Wheel();
      this.right_wheel.x(wheel_distance).z(wheel_distance);
      this.frontl_wheel = new Wheel();
      this.frontl_wheel.x(-wheel_distance).z(-wheel_distance);
      this.frontr_wheel = new Wheel();
      this.frontr_wheel.x(-wheel_distance).z(wheel_distance);
    }

    UnidirectionalWheels.prototype.connect = function(wheel, scene, x, z) {
      var connection;
      connection = new Physijs.DOFConstraint(wheel.mesh(), this.cylinder.mesh(), new THREE.Vector3(x, 0, z));
      scene.addConstraint(connection);
      return connection;
    };

    UnidirectionalWheels.prototype.show = function(scene) {
      var connection;
      scene.add(this.cylinder.mesh());
      scene.add(this.left_wheel.mesh());
      scene.add(this.right_wheel.mesh());
      scene.add(this.frontl_wheel.mesh());
      scene.add(this.frontr_wheel.mesh());
      connection = this.connect(this.frontl_wheel, scene, -wheel_distance, -wheel_distance);
      connection.setAngularLowerLimit({
        x: 0,
        y: 0,
        z: 0
      });
      connection.setAngularUpperLimit({
        x: 0,
        y: 0,
        z: 0
      });
      connection = this.connect(this.frontr_wheel, scene, -wheel_distance, wheel_distance);
      connection.setAngularLowerLimit({
        x: 0,
        y: 0,
        z: 0
      });
      connection.setAngularUpperLimit({
        x: 0,
        y: 0,
        z: 0
      });
      connection = this.connect(this.left_wheel, scene, wheel_distance, -wheel_distance);
      connection.setAngularLowerLimit({
        x: -Math.PI / 8,
        y: 0,
        z: 1
      });
      connection.setAngularUpperLimit({
        x: Math.PI / 8,
        y: 0,
        z: 0
      });
      connection.configureAngularMotor(2, 1, 0, 5011, 2000);
      connection.enableAngularMotor(2);
      connection = this.connect(this.right_wheel, scene, wheel_distance, wheel_distance);
      connection.setAngularLowerLimit({
        x: -Math.PI / 8,
        y: 0,
        z: 1
      });
      connection.setAngularUpperLimit({
        x: Math.PI / 8,
        y: 0,
        z: 0
      });
      connection.configureAngularMotor(2, 1, 0, 5011, 2000);
      return connection.enableAngularMotor(2);
    };

    return UnidirectionalWheels;

  })();

  CodeyParts.Body = (function() {
    function Body() {
      var main_material;
      main_material = Physijs.createMaterial(new THREE.MeshNormalMaterial(), .8, .2);
      this.main_body = new Physijs.BoxMesh(new THREE.CylinderGeometry(10, 10, 10, 10, 1, false), main_material, 1);
      this.main_body.position.y = 100;
      this.main_body.receiveShadow = this.main_body.castShadow = true;
      this.main_body.position.x = 0;
      this.main_body.position.z = 0;
    }

    Body.prototype.mesh = function() {
      return this.main_body;
    };

    return Body;

  })();

  Codey = (function(_super) {
    __extends(Codey, _super);

    Codey.build_robot = function(scene) {
      return new Codey(scene);
    };

    function Codey(scene) {
      var unidirectional_wheels;
      unidirectional_wheels = new CodeyParts.UnidirectionalWheels();
      console.log(unidirectional_wheels);
      unidirectional_wheels.show(scene);
    }

    Codey.prototype.mashes = function() {
      return [this.main_body, this.left_wheel];
    };

    return Codey;

  })(Character);

  Dimension = (function() {
    function Dimension(height, width, depth) {
      this.height = height;
      this.width = width;
      this.depth = depth;
    }

    Dimension.prototype.h = (function() {
      return this.height;
    });

    Dimension.prototype.w = (function() {
      return this.width;
    });

    Dimension.prototype.d = (function() {
      return this.depth;
    });

    return Dimension;

  })();

  Position = (function() {
    function Position(x, y, z) {
      this.x = x;
      this.y = y;
      this.z = z;
    }

    return Position;

  })();

  PositionCenter = (function(_super) {
    __extends(PositionCenter, _super);

    function PositionCenter() {
      this.x = 0;
      this.y = 0;
      this.z = 0;
    }

    return PositionCenter;

  })(Position);

  Cube = (function() {
    function Cube(dimension, position) {
      var geometry, material;
      if (dimension == null) {
        dimension = new Dimension(10, 10, 10);
      }
      if (position == null) {
        position = new PositionCenter();
      }
      geometry = new THREE.CubeGeometry(dimension.h(), dimension.w(), dimension.d());
      material = new THREE.MeshBasicMaterial({
        wireframe: true,
        color: 'red'
      });
      this.mesh = new THREE.Mesh(geometry, material);
      this.mesh.position.x = position.x;
      this.mesh.position.y = position.y;
      this.mesh.position.z = position.z;
    }

    Cube.prototype.animate = function() {};

    Cube.prototype.t = function() {
      return this.mesh;
    };

    return Cube;

  })();

  window.Floor = (function() {
    function Floor() {
      var face, geometry, i, l, material, _i, _ref;
      geometry = new THREE.PlaneGeometry(2000, 2000, 100, 100);
      geometry.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI / 2));
      l = geometry.faces.length;
      for (i = _i = 0, _ref = l - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        face = geometry.faces[i];
        face.vertexColors[0] = new THREE.Color();
        face.vertexColors[1] = new THREE.Color();
        face.vertexColors[2] = new THREE.Color().setHSL(0.1, 0.4, 0.2);
      }
      material = new THREE.MeshBasicMaterial({
        vertexColors: THREE.VertexColors
      });
      this.mesh = new THREE.Mesh(geometry, material);
    }

    return Floor;

  })();

  Renderer = (function() {
    function Renderer() {
      this.renderer = new THREE.WebGLRenderer({
        antialias: true
      });
      this.renderer.setSize(Window.w(), Window.h());
      this.renderer.setClearColor(0xcccccc);
      this.renderer.shadowMapEnabled = true;
      this.renderer.shadowMapSoft = true;
      document.body.appendChild(this.renderer.domElement);
    }

    Renderer.prototype.rendererClass = function() {
      if (Window.webGL()) {
        return THREE.WebGLRenderer;
      } else {
        return THREE.CanvasRenderer;
      }
    };

    Renderer.prototype.t = function() {
      return this.renderer;
    };

    return Renderer;

  })();

  Window = (function() {
    function Window() {}

    Window.aspectRatio = function() {
      return this.w() / this.h();
    };

    Window.webGL = function() {
      return !!window.WebGLRenderingContext;
    };

    Window.w = function() {
      return window.innerWidth;
    };

    Window.h = function() {
      return window.innerHeight;
    };

    return Window;

  })();

  Movement = (function() {
    function Movement(camera) {
      this.update = __bind(this.update, this);
      var onKeyDown, onKeyUp;
      this.pitchObject = new THREE.Object3D();
      this.pitchObject.add(camera);
      this.yawObject = new THREE.Object3D();
      this.yawObject.position.y = 10;
      this.yawObject.add(this.pitchObject);
      this.moveForward = false;
      this.moveBackward = false;
      this.moveLeft = false;
      this.moveRight = false;
      this.rotateLeft = false;
      this.rotateRight = false;
      this.rotateUp = false;
      this.rotateDown = false;
      this.isOnObject = false;
      this.velocity = new THREE.Vector3();
      this.pi_2 = Math.PI / 2;
      onKeyDown = (function(_this) {
        return function(event) {
          switch (event.keyCode) {
            case 81:
              return _this.moveLeft = true;
            case 69:
              return _this.moveRight = true;
            case 38:
            case 87:
              return _this.moveForward = true;
            case 37:
            case 65:
              return _this.rotateLeft = true;
            case 40:
            case 83:
              return _this.moveBackward = true;
            case 39:
            case 68:
              return _this.rotateRight = true;
          }
        };
      })(this);
      onKeyUp = (function(_this) {
        return function(event) {
          switch (event.keyCode) {
            case 81:
              return _this.moveLeft = false;
            case 69:
              return _this.moveRight = false;
            case 38:
            case 87:
              return _this.moveForward = false;
            case 37:
            case 65:
              return _this.rotateLeft = false;
            case 40:
            case 83:
              return _this.moveBackward = false;
            case 39:
            case 68:
              return _this.rotateRight = false;
          }
        };
      })(this);
      document.addEventListener('keydown', onKeyDown, false);
      document.addEventListener('keyup', onKeyUp, false);
    }

    Movement.prototype.getObject = function() {
      return this.yawObject;
    };

    Movement.prototype.onObject = function(boolean) {
      return this.isOnObject = boolean;
    };

    Movement.prototype.getDirection = function() {
      var direction, rotation;
      direction = new THREE.Vector3(0, 0, -1);
      rotation = new THREE.Euler(0, 0, 0, "YXZ");
      return (function(_this) {
        return function(v) {
          rotation.set(_this.pitchObject.rotation.x, _this.yawObject.rotation.y, 0);
          v.copy(direction).applyEuler(rotation);
          return v;
        };
      })(this);
    };

    Movement.prototype.update = function(delta) {
      var canJump, movementX, movementY;
      delta *= 0.1;
      this.velocity.x += (-this.velocity.x) * 0.08 * delta;
      this.velocity.z += (-this.velocity.z) * 0.08 * delta;
      this.velocity.y -= 0.25 * delta;
      if (this.moveForward) {
        this.velocity.z -= 0.12 * delta;
      }
      if (this.moveBackward) {
        this.velocity.z += 0.12 * delta;
      }
      if (this.moveLeft) {
        this.velocity.x -= 0.12 * delta;
      }
      if (this.moveRight) {
        this.velocity.x += 0.12 * delta;
      }
      if (this.isOnObject === true) {
        this.velocity.y = Math.max(0, this.velocity.y);
      }
      movementX = 0;
      movementY = 0;
      if (this.rotateLeft) {
        movementX = -3 * delta;
      }
      if (this.rotateRight) {
        movementX = 3 * delta;
      }
      if (this.yawObject.position.y < 10) {
        this.velocity.y = 0;
        this.yawObject.position.y = 10;
        return canJump = true;
      }
    };

    return Movement;

  })();

}).call(this);
