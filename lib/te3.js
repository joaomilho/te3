// Generated by CoffeeScript 1.7.1
(function() {
  var BLOCK_HEIGHT, BLOCK_WIDTH, BOTTOM, BlockBase, BlockE, BlockI, BlockL, BlockLV, BlockO, CENTER, CUBE_SIZE, Camera, ComponentBase, GRID_HEIGHT, GRID_HEIGHT_IN_CUBES, GRID_WIDTH, GRID_WIDTH_IN_CUBES, Grid, LEFT, RIGHT, RandomBlock, Renderer, Scene, TOP, Te3, Window,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  CUBE_SIZE = 50;

  BLOCK_HEIGHT = 4 * CUBE_SIZE;

  BLOCK_WIDTH = 3 * CUBE_SIZE;

  GRID_WIDTH_IN_CUBES = 9;

  GRID_HEIGHT_IN_CUBES = 16;

  GRID_WIDTH = CUBE_SIZE * GRID_WIDTH_IN_CUBES;

  GRID_HEIGHT = CUBE_SIZE * GRID_HEIGHT_IN_CUBES;

  TOP = GRID_HEIGHT;

  LEFT = 0;

  BOTTOM = 0;

  RIGHT = GRID_WIDTH;

  CENTER = GRID_WIDTH / 2;

  ComponentBase = (function() {
    function ComponentBase() {}

    ComponentBase.prototype.t = function() {
      return this.component;
    };

    return ComponentBase;

  })();

  Window = (function() {
    function Window() {}

    Window.aspectRatio = function() {
      return this.w() / this.h();
    };

    Window.w = function() {
      return window.innerWidth;
    };

    Window.h = function() {
      return window.innerHeight;
    };

    return Window;

  })();

  Camera = (function(_super) {
    __extends(Camera, _super);

    function Camera() {
      this.component = new THREE.PerspectiveCamera(45, Window.aspectRatio(), 1, 2000);
      this.component.position.z = GRID_WIDTH * 3;
      this.component.position.x = GRID_WIDTH / 2;
      this.component.position.y = GRID_HEIGHT / 2;
    }

    return Camera;

  })(ComponentBase);

  Renderer = (function(_super) {
    __extends(Renderer, _super);

    Renderer.prototype.component = new THREE.WebGLRenderer({
      antialias: true
    });

    Renderer.prototype.color = 0xcccccc;

    function Renderer() {
      this.component.setSize(Window.w(), Window.h());
      this.component.setClearColor(this.color);
      document.body.appendChild(this.component.domElement);
    }

    Renderer.prototype.render = function(scene, camera) {
      return this.component.render(scene.t(), camera.t());
    };

    return Renderer;

  })(ComponentBase);

  Scene = (function(_super) {
    __extends(Scene, _super);

    function Scene() {
      return Scene.__super__.constructor.apply(this, arguments);
    }

    Scene.prototype.component = new THREE.Scene;

    Scene.prototype.add = function(object) {
      return this.component.add(object.t());
    };

    return Scene;

  })(ComponentBase);

  Grid = (function(_super) {
    __extends(Grid, _super);

    Grid.prototype.color = 0xbbbbbb;

    function Grid() {
      this.component = new THREE.Mesh(new THREE.CubeGeometry(GRID_WIDTH, GRID_HEIGHT, CUBE_SIZE), new THREE.MeshBasicMaterial({
        wireframe: true,
        color: this.color
      }));
      this.component.position.x = GRID_WIDTH / 2;
      this.component.position.y = GRID_HEIGHT / 2;
    }

    return Grid;

  })(ComponentBase);

  BlockBase = (function(_super) {
    __extends(BlockBase, _super);

    BlockBase.prototype.adjust = CUBE_SIZE / 2;

    BlockBase.prototype.initialX = 4;

    function BlockBase() {
      this.component = this.merge(this.geometries());
      this.x(this.initialX * CUBE_SIZE);
      this.y(TOP);
    }

    BlockBase.prototype.geometries = function() {
      var geometries, geometry, line, row, x, y, _i, _j, _len, _len1, _ref;
      geometries = [];
      y = 0;
      _ref = this.format;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        line = _ref[_i];
        y++;
        x = 0;
        for (_j = 0, _len1 = line.length; _j < _len1; _j++) {
          row = line[_j];
          x++;
          if (row === 0) {
            continue;
          }
          geometry = this.geometry();
          geometry.applyMatrix(new THREE.Matrix4().makeTranslation((x - 2) * CUBE_SIZE, -(y - 1) * CUBE_SIZE, 0));
          geometries.push(geometry);
        }
      }
      return geometries;
    };

    BlockBase.prototype.geometry = function() {
      return new THREE.CubeGeometry(CUBE_SIZE, CUBE_SIZE, CUBE_SIZE);
    };

    BlockBase.prototype.merge = function(geometries) {
      var firstGeometry, geometry, material, _i, _len;
      firstGeometry = geometries.shift();
      for (_i = 0, _len = geometries.length; _i < _len; _i++) {
        geometry = geometries[_i];
        THREE.GeometryUtils.merge(firstGeometry, geometry);
      }
      material = new THREE.MeshBasicMaterial({
        wireframe: true,
        color: this.color
      });
      this.initialPosition(firstGeometry);
      return new THREE.Mesh(firstGeometry, material);
    };

    BlockBase.prototype.flip = function() {};

    BlockBase.prototype.initialPosition = function(geometry) {
      var x;
      x = this.translateX || 0;
      return geometry.applyMatrix(new THREE.Matrix4().makeTranslation(25 + CUBE_SIZE * x, 25 + CUBE_SIZE * 3, 0));
    };

    BlockBase.prototype.y = function(value) {
      return this.component.position.y = value;
    };

    BlockBase.prototype.x = function(value) {
      return this.component.position.x = value;
    };

    BlockBase.prototype.down = function() {
      if (!this.bottomLimit()) {
        return this.component.position.y -= CUBE_SIZE;
      }
    };

    BlockBase.prototype.bottomLimit = function() {
      return this.component.position.y <= BOTTOM;
    };

    BlockBase.prototype.left = function() {
      if (!this.leftLimit()) {
        return this.component.position.x -= CUBE_SIZE;
      }
    };

    BlockBase.prototype.leftLimit = function() {
      return this.component.position.x <= LEFT;
    };

    BlockBase.prototype.right = function() {
      if (!this.rightLimit()) {
        return this.component.position.x += CUBE_SIZE;
      }
    };

    BlockBase.prototype.rightLimit = function() {
      return this.component.position.x >= RIGHT - this.width * CUBE_SIZE;
    };

    return BlockBase;

  })(ComponentBase);

  BlockE = (function(_super) {
    __extends(BlockE, _super);

    function BlockE() {
      return BlockE.__super__.constructor.apply(this, arguments);
    }

    BlockE.prototype.format = [[0, 0, 0], [0, 0, 0], [0, 1, 0], [1, 1, 1]];

    BlockE.prototype.color = 'green';

    BlockE.prototype.width = 3;

    BlockE.prototype.translateX = 1;

    BlockE.prototype.initialX = 3;

    return BlockE;

  })(BlockBase);

  BlockI = (function(_super) {
    __extends(BlockI, _super);

    function BlockI() {
      return BlockI.__super__.constructor.apply(this, arguments);
    }

    BlockI.prototype.format = [[0, 1, 0], [0, 1, 0], [0, 1, 0], [0, 1, 0]];

    BlockI.prototype.color = 'blue';

    BlockI.prototype.width = 1;

    return BlockI;

  })(BlockBase);

  BlockL = (function(_super) {
    __extends(BlockL, _super);

    function BlockL() {
      return BlockL.__super__.constructor.apply(this, arguments);
    }

    BlockL.prototype.format = [[0, 0, 0], [0, 1, 0], [0, 1, 0], [0, 1, 1]];

    BlockL.prototype.color = 'red';

    BlockL.prototype.width = 2;

    return BlockL;

  })(BlockBase);

  BlockLV = (function(_super) {
    __extends(BlockLV, _super);

    function BlockLV() {
      return BlockLV.__super__.constructor.apply(this, arguments);
    }

    BlockLV.prototype.format = [[0, 0, 0], [0, 0, 1], [0, 0, 1], [0, 1, 1]];

    BlockLV.prototype.color = 'orange';

    BlockLV.prototype.width = 2;

    BlockLV.prototype.initialX = 3;

    return BlockLV;

  })(BlockBase);

  BlockO = (function(_super) {
    __extends(BlockO, _super);

    function BlockO() {
      return BlockO.__super__.constructor.apply(this, arguments);
    }

    BlockO.prototype.format = [[0, 0, 0], [0, 0, 0], [0, 1, 1], [0, 1, 1]];

    BlockO.prototype.color = 'yellow';

    BlockO.prototype.width = 2;

    return BlockO;

  })(BlockBase);

  RandomBlock = (function() {
    function RandomBlock() {}

    Array.prototype.sample = function() {
      return this[Math.floor(Math.random() * this.length)];
    };

    RandomBlock.blocks = [BlockE, BlockI, BlockL, BlockLV, BlockO];

    RandomBlock.choose = function() {
      var blockClass;
      blockClass = this.blocks.sample();
      return new blockClass;
    };

    return RandomBlock;

  })();

  Te3 = (function() {
    Te3.prototype.dificulty = 36;

    Te3.prototype.timer = 0;

    Te3.prototype.renderer = new Renderer;

    Te3.prototype.scene = new Scene;

    Te3.prototype.camera = new Camera;

    Te3.prototype.grid = new Grid;

    function Te3() {
      this.animate = __bind(this.animate, this);
      this.blockMovement = __bind(this.blockMovement, this);
      this.scene.add(this.camera);
      this.scene.add(this.grid);
      this.addBlock();
      this.animate();
      window.onkeydown = this.blockMovement;
    }

    Te3.prototype.addBlock = function() {
      return this.scene.add(this.currentBlock = RandomBlock.choose());
    };

    Te3.prototype.blockMovement = function(event) {
      switch (event.keyCode) {
        case 37:
        case 65:
          return this.currentBlock.left();
        case 39:
        case 68:
          return this.currentBlock.right();
        case 40:
        case 83:
          return this.currentBlock.down() || this.addBlock();
        case 38:
        case 87:
          return this.currentBlock.flip();
      }
    };

    Te3.prototype.animate = function() {
      requestAnimationFrame(this.animate);
      this.timer++;
      if (this.timer % this.dificulty === 0) {
        this.currentBlock.down() || this.addBlock();
      }
      return this.renderer.render(this.scene, this.camera);
    };

    return Te3;

  })();

  new Te3;

}).call(this);
